{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-22T19:06:50.419-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-22T23:49:16.808-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "ADvpn86gDQC8VJj6DxVTDQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "# Morph general properties\r\n\r\n* Morph is a superclass of graphical objects; it has methods that let those objects respond to events and display themselves.\r\n* All morphs have bounds (rectangles on the screen), and can have submorphs.\r\n• The world (the screen or page) is itself a morph. This gives you the basic model for a scene graph displayed on the screen.\r\n• A hand object, shown as the cursor (and also part of the world), can pick up other objects and drop them elsewhere, thus effecting not only motion but also changes in the structure of the scene graph. The hand is also the source of user event messages such as mouseDown: and mouseMove:.\r\n• User events such as mouseDown: are passed as messages from the screen, down through the scene graph, to the frontmost morph that contains the location of the event.\r\n• Morphs typically define methods that respond to user input events like mouseDown:, or to the passage of time through a tick message from the world.\r\n• When a morph’s position or appearance changes, a changed message causes the Morphic display system to update the screen efficiently, and without flashing.\r\n• Both normal screen changes and animations are handled by a simple iterative kernel:\r\n    forever do:\r\n    detect and dispatch user events, such as mouseDown:, mouseMove:\r\n    run step methods defined for any morphs,\r\n    compute the affected screen area, and update it using double buffering\r\n(source: the evolution of smalltalk.pdf)\r\n\r\n# coordinate systems:\r\nA morph has two coordinate system:\r\n- from the outsite world\r\n- from itself, its bounds\r\nAccesssible in the geometry protocol\r\nFor example, if you specify a point directly, Morph will position it in the world.\r\nBounds are recalculated when we move the morph, and coordinate associated with it\r\nare recalculated accordingly.\r\n\r\nMorphic:\r\nUn Morph est définis par son \"bounds\", soit le rectangle délimitant son espace.\r\nhttp://wiki.squeak.org/squeak/morphic\r\nhttps://wiki.squeak.org/squeak/2141\r\n\r\n\r\n\r\nPour créer un nouveau widget:\r\n- drawOn: dessine le nouveau widget.\r\n- containsPoint: pour définir la place effectivement occupé à l'ecran\r\n\r\n\r\nGestion de la souris et des évènement.\r\n- handleMouseDown: et \r\n    - mouseDown:; mouseUp:\r\n\r\n- handleMouseOver:\r\n    - mouseEnter: et mouseLeave:\r\n\r\n- handleKeyStroke\r\n\r\nPour combiner les Morph:\r\n- addMorph: and all method in protocol 'submorphs-add/remove'\r\n- position, dans le protocol geometry\r\nNote that the geometry protocol is used to position element inside a Morph.\r\nIt can be used as well in the drawOn: message, so it used either for drawing\r\nor for position Morph when we combine them.\r\n- layout policy: https://wiki.squeak.org/squeak/2141\r\n\r\n\r\nAnimation:\r\n- step and StepTime\r\n\r\nDrag&Drop:\r\n\r\nGet Form generated by Morph: AthensHello new imageForm  \r\n\r\nWhen you open a Morph with the message openInWorld, it'll add itself to the \r\nglobal world Morph: `aWorld addMorph: self.`\r\n\r\n\r\nExemple de construction de fenêtre morphic avec modèle: FontChooserMorph et FontChooser\r\nExemple de morph affiché dynamiquement: CalendarMorph on: '2020-01-21' asDate\r\nExemple de morph construit par aggregation de morph: CheckboxMorph  new openInWorld \r\n- on dérive d'un morph, et on ajoute les nouveaux morph intéressant.\r\n\r\n\r\nself bounds corner - self bounds origin\r\nbounds is a Rectangle object. As such, you can find its coordinate, \r\neither relative from Pharo world: bounds origin, bounds corner,\r\nor by itself, going from 0@0 to bounds extend\r\n\r\n\r\nCanvas utilisé par défaut: FormCanvas\r\nAthen dessine dans une image, qu'il envoie ensuite dans le canvas.\r\n\r\n\r\nMorph subclass: #AthensDemoMorph\r\n\r\ndrawOn: aCanvas\r\n\r\nself halt.\r\n\tself render.\r\n\r\n\taCanvas\r\n\t\tdrawImage: surface asForm at: self bounds origin\r\n\r\n\r\nasForm\r\n\t\"create a form and copy an image data there\"\r\n\tself checkSession.\r\n\tself flush.\r\n \t^ (AthensCairoSurfaceForm extent: (self width@(self height)) depth: 32 bits: id)\r\n\t\tsurface: self;\r\n\t\tyourself\r\n\r\n\r\nMorph a trop de responsabilité:\r\n- layout de sous-morph (protocol geometry)\r\n- styling \r\n- gestion des menus du World\r\n\r\n\r\nHandMorph -> souris.\r\n\r\nWorldMorph doOneCycle -> permet de rafraichir le monde.\r\nVa parcourir les sous-morph qui composent le monde, et va les dessiner, en utilisant le canvas par défaut: FormCanvas\r\n\r\nLe canvas va utiliser la classe Form, qui est un espace rectangulaire pour mettre une image.\r\nLa classe Form utilise ensuite BitBlt pour envoyer son dessin vers l'écran\r\n\r\n\r\n# morphic world\r\n- managing system cursor:\r\n[https://github.com/pharo-project/pharo/commit/a9e5d8cbb142334e002875c72fe4b8eb9f78e64d#diff-9de4d9ca26fa0ecc18374ee9e3087f5309eac071b9eb992e3ff03c27a63aa4a6]\r\n\r\n- managing display\r\n[https://github.com/pharo-project/pharo/commit/4e3d8862af9e72110a97bc314ea696677fb1226e#diff-9de4d9ca26fa0ecc18374ee9e3087f5309eac071b9eb992e3ff03c27a63aa4a6] \r\n\r\n- updating display resolution\r\n[https://github.com/pharo-project/pharo/commit/0a6041d7a3331d827a23d465373e591d4fc33e67#] \r\n\r\n# drawing \r\n\r\nMorphic is currently the way to go on pharo for Graphics. However, all existing canvas\r\nare pixel based, and not vector based. This can be an issue with current screen,\r\nwhere the resolution can differ from machine to machine.\r\n\r\nEnter Athens, a vector based graphic API. Under the scene, it can either use\r\nballoon Canvas, or the cairo graphic library for the rasterization phase.\r\n\r\nWhen you integrate Athens with Morphic, you'll use the rendering engine to\r\ncreate your picture. It's then transformed in a Form and displayed using on\r\nthe screen using BitBlt.\r\n\r\n# Athens with Morphic\r\nWe'll see how to use Athens directly integrated with Morphic. So will be the \r\nbase class we'll use after for all our experiment:\r\n\r\nFirst, we define a class, which inherit from Morph:\r\n```smalltalk\r\nMorph subclass: #AthensHello\r\n    instanceVariableNames: 'surface'\r\n    classVariableNames: ''\r\n    package: 'Athens-Hello'\r\n```\r\n\r\nDuring the initialization phase, we'll create our Athens surface:\r\n```smalltalk\r\nAthensHello >> initialize\r\n    super initialize.\r\n    self extent: self defaultExtent.\r\n    surface := AthensCairoSurface extent: self extent.\r\n```\r\nwhere defaultExtent is simply defined as\r\n```smalltalk\r\nAthensHello >> defaultExtent\r\n    ^ 400@400\r\n```\r\nThe drawOn: method, mandatory in Morph subclasses, will ask Athens to render\r\nits drawing, and it'll then display it in a Morphic canvas as a Form (a bitmap \r\npictures)\r\n\r\n```\r\nAthensHello >> drawOn: aCanvas\r\n\r\n    self renderAthens.\r\n    surface displayOnMorphicCanvas: aCanvas at: bounds origin.\r\n```\r\n\r\nOur actual Athens code is located into renderAthens method:, and the result is\r\nstored in the surface instance variable.\r\n```smalltalk\r\nAthensHello >> renderAthens\r\n|font|\r\nfont := LogicalFont familyName: 'Arial' pointSize: 10.\r\n\r\n    surface drawDuring: [:canvas | \r\n        \"canvas pathTransform loadIdentity.\"\r\n        surface clear. \r\n        canvas setPaint: ((LinearGradientPaint from: 0@0  to: self extent) colorRamp: {  0 -> Color white. 1 -> Color black }).\r\n        canvas drawShape: (0@0 extent: self extent). \r\n        canvas setFont: font. \r\n        canvas setPaint: Color pink.\r\n        canvas pathTransform translateX: 20 Y: 20 + (font getPreciseAscent); scaleBy: 2; rotateByDegrees: 25.\r\n        canvas drawString: 'Hello Athens in Pharo/Morphic'\r\n        \r\n    ].\r\n```\r\nTo test your code, let's add an helper method. This will add a button on the left\r\nof the method name. When you click on it, it'll execute the content of the \r\nscript instruction.\r\n```smalltalk\r\nAthensHello >> open\r\n    <script: 'self new openInWindow'>\r\n```\r\nOn last things. You can already create the window, and see a nice gradient, with \r\na greeting text. However, you'll notice, if you resize your window, that the \r\nAthens content is not resized. To fix this, we'll need one last method.\r\n```smalltalk\r\nAthensHello >> extent: aPoint\r\n    | newExtent |\r\n    newExtent := aPoint rounded.\r\n    (bounds extent closeTo: newExtent)\r\n        ifTrue: [ ^ self ].\r\n    self changed.\r\n    bounds := bounds topLeft extent: newExtent.\r\n    surface := AthensCairoSurface extent: newExtent.\r\n    self layoutChanged.\r\n    self changed\r\n```\r\n\r\nCongratulation, you have now created your first morphic windows where content\r\nis rendered using Athens.\r\n"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2022-07-22T19:06:43.771-04:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2022-07-22T19:07:00.841-04:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "Morphic introduction"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "78aae89f-cea0-0d00-bc53-53950f15530d"
	}
}