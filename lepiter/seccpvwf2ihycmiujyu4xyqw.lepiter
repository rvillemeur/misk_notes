{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-22T19:34:02.155-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-03T17:28:52.09-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "4FIDAc+gDQC9K1sxDxVTDQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##introduction\r\n\r\nYour language isn't broken, it's doing floating point math. **Computers can only natively store integers**, so they need some way of representing decimal numbers. This representation comes with some degree of inaccuracy. That's why, more often than not, .1 + .2 != .3.\r\n\r\nThe most common situation is illustrated by the decimal number 0.1. Although it has a finite decimal representation, in binary it has an **infinite** repeating representation.\r\n \r\nWhy does this happen? It's actually pretty simple. When you have a base 10 system (like ours), it can only express fractions that use a prime factor of the base. The prime factors of 10 are 2 and 5. So 1/2, 1/4, 1/5, 1/8, and 1/10 can all be expressed cleanly because the denominators all use prime factors of 10. \r\n\r\nIn contrast, 1/3, 1/6, and 1/7 are all repeating decimals because their denominators use a prime factor of 3 or 7. In binary (or base 2), the only prime factor is 2. So you can only express fractions cleanly which only contain 2 as a prime factor. \r\n\r\nIn binary, 1/2, 1/4, 1/8 would all be expressed cleanly as decimals. While, 1/5 or 1/10 would be repeating decimals. So 0.1 and 0.2 (1/10 and 1/5) while clean decimals in a base 10 system, are repeating decimals in the base 2 system the computer is operating in. When you do math on these repeating decimals, you end up with leftovers which carry over when you convert the computer's base 2 (binary) number into a more human readable base 10 number.\r\n\r\nIf the leading digit is nonzero, then the representation is said to be normalized. Requiring that a floating-point representation be normalized makes the representation unique. Since floating-point numbers are always normalized, the most significant bit of the significand is always 1, and there is no reason to waste a bit of storage representing it. Formats that use this trick are said to have a hidden bit.\r\n\r\nIEEE 754 single precision is encoded in 32 bits using \r\n- 1 bit for the sign, \r\n- 8 bits for the exponent, and \r\n- 23 bits for the significand (mantissa). \r\n\r\nHowever, it uses a hidden bit, so the significand is 24 bits (p = 24), even though it is encoded using only 23 bits. It can be read with formula like\r\n`(-1)^sign * 2^(exponent - 127) * (1 + sum(i = 1 -> 23) b(i)*2^-i)`\r\n###Exemple: Exprimer 0.1 en nombre flottant.\r\n\r\n```txt\r\ns eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm    1/n\r\n0 01111011 10011001100110011001101\t=> 1/10, chiffre en 32 bits.\r\n```\r\n#### step 1: signe du chiffre (positif ou négatif)\r\nSur 1 bit\r\n0: positif\r\n1: négatif\r\n\r\n**=> 0, we deal with a positive number**\r\n#### Step 2: eeeeeeee: Exposant ou multiplier (la puissance à laquelle est poussé le chiffre)\r\n ou biased exponent - trouvé par la formule `2^(k-1) - 1` \r\n => 2^(8 -1) - 1 = 127\r\nLa valeur de l'exposant est '2^(exponent - 127)'\r\nsur 8 bits 0 -> 255\r\n\r\n```txt\r\n  00000000\t=> 0\r\n+ 01000000\t=> 64\r\n+ 00100000    => 32\r\n+ 00010000\t=> 16\r\n+ 00001000    => 8\r\n+ 00000010    => 2\r\n+ 00000001\t=> 1\r\n= 01111011  => 123\r\n```\r\n\r\nexponant =  2^(exponent - 127) = `2^(123 - 127) = 2^(-4)`\r\n**=> exponant = 2^-4 ou 1/16.**\r\n#### Step 3: mmmmmmmmmmmmmmmmmmmmmmm: mantisse ou fraction\r\nsur 23 bits: 1/2 -> 1/8388608\r\nIt consists of 1 (the implicit base) plus (for all those bits with each being worth 1/(2^n) as n starts at 1 and increases to the right). Remember that 1 bit is hidden (see normalized text above)\r\n\r\n```txt\r\n  10000000000000000000000 => 1/2 (1/2^1) \r\n+ 00010000000000000000000 => 1/16 (1/2^4)\r\n+ 00001000000000000000000 => 1/32 (1/2^5)\t\r\n+ 00000001000000000000000 => 1/256\r\n+ 00000000100000000000000 => 1/512\r\n+ 00000000000100000000000 => 1/4096\r\n+ 00000000000010000000000 => 1/8192\r\n+ 00000000000000010000000 => 1/65536\r\n+ 00000000000000001000000 => 1/131072 \r\n+ 00000000000000000001000 => 1/1048576\r\n+ 00000000000000000000100 => 1/2097152\r\n+ 00000000000000000000001 => 1/8388608 (1/2^23) \r\n= 10011001100110011001101 => 1.60000002384185791015625\r\n```\r\n\r\n**mantissa = 1.60000002384185791015625**\r\n###Step 4: combaine sign, mantisse and exponent\r\nmantisse * exposant \r\n = 1.60000002384185791015625 * 1/16 \r\n **= 0.100000001490116119384765625**\r\n \r\n We are a little offset from our matical representation of 0.1"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-03T17:12:02.434-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-03T17:12:31.405-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "0Ov/yk36DQCCisVGD1AMsw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Express 0.5 in binary\r\nThe 0.5 example is substantially easier. It's represented as:\r\n\r\n```txt\r\ns eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm\r\n0 01111110 00000000000000000000000\r\n```\r\n\r\nwhich means it's the implicit base, 1, plus no other additives (all the mantissa bits are zero).\r\n\r\nThe sign is again positive. \r\nThe exponent is 64+32+16+8+4+2 = 126 - 127 bias = -1.\r\nHence the multiplier is 2-1 which is 1/2 or 0.5.\r\n\r\nSo the final value is 1 multiplied by 0.5, or 0.5. Voila!"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-03T17:12:14.696-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-03T17:12:15.655-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "QAa7y036DQCCmX5QD1AMsw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##reference\r\nhttps://stackoverflow.com/questions/3448777/how-to-represent-0-1-in-floating-point-arithmetic-and-decimal\r\nhttps://www.h-schmidt.net/FloatConverter/IEEE754.html\r\nhttps://en.wikipedia.org/wiki/IEEE_754-1985\r\nhttps://en.wikipedia.org/wiki/Guard_digit\r\nhttp://0.30000000000000004.com/\r\nhttps://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html."
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2022-07-22T19:33:52.873-04:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-09-03T16:59:59.682-04:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "floating numbers representation in binary"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "28ca0201-cfa0-0d00-bd2a-da080f15530d"
	}
}