{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:00:49.362-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:04:57.625-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "UASru9KgDQCshN/BDgkDmw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "[Indication sur la programmation fonctionnelle](https://en.wikipedia.org/wiki/Programming_paradigm)\r\n\r\n\r\n#Comparatif de paradigme de programmation.\r\n\r\n# programmation procédurale\r\npour la programmation procedurale (ex: pascal, c), tout n'est qu'un ensemble d'instruction pour modifier l'état d'une variable, en passant par des fonctions ou des procédures. Cependant, contrairement à la programmation fonctionnelle, les fonctions ne sont pas \"pure\", et peuvent modifier des variables en dehors de leur portée (ou scope en anglais). On y retrouve la notion de boucle "
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:07:35.741-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:12:43.934-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "qM7j09KgDQCsimkFDgkDmw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "#Programmation Objet\r\npour la programmation orienté object (ex: smalltalk), tout est object. \r\n\r\n###Example:\r\n**1** est un object de type **integer**, pour lequel je peux envoyer des messages. Un object peut être vu comme une cellule ou un mini-ordinateur, responsable de garder son état.\r\n\r\n[I made up the term 'object-oriented', and I can tell you I didn't have C++ in mind](https://tinlizzie.org/IA/index.php/Alan_Kay_at_OOPSLA_1997:_The_Computer_Revolution_has_not_Happened_Yet)\r\n-- Alan Kay, OOPSLA '97\r\n\r\n[I was too blythe about the term back in the 60s and should have chosen something like \"message oriented\"](https://softwareengineering.stackexchange.com/questions/46592/so-what-did-alan-kay-really-mean-by-the-term-object-oriented#comment147720_46593)\r\n– Alan Kay Jun 8, 2011 at 16:27\r\n"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:00:58.591-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:14:01.931-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "GNc3vNKgDQCshSlCDgkDmw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "## encapsulation, héritage et polymorphisme\r\nAlan Kay définissait la programmation object comme suit: \"*OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.*\"\r\n\r\n- objects being like biological cells and/or individual computers on a network,   only able to communicate with messages\r\n- get rid of data\r\n- each object could have several algebras associated with it, and there could   be families of these, and that these would be very very useful. The term  \"*polymorphism*\" was imposed much later (I think by Peter Wegner) and   it isn't quite valid, since it really comes from the nomenclature of \r\n  functions, and I wanted quite a bit more than functions.\r\n\r\n[source](http://www.purl.org/stefan_ram/pub/doc_kay_oop_en)\r\n\r\nOn associe aussi à la programmation objet les 3 caractéristique suivantes:\r\n * encapsulation.\r\n * héritage.\r\n * polymorphisme.\r\n\r\nL'encapsulation permet de masquer l'état interne des objects. C'est un état qui est propre à l'implémentation du langage de programmation. C++ permet d'avoir des attributs public, private ou protected, alors qu'en Smalltalk, toutes les variables sont privés, et les méthodes publiques. Cela veut dire aussi que l'état interne de l'object doit être inconnu pour ses clients.\r\n\r\nLe polymorphisme permet de définir des objets ayant des signatures identiques. Cela permet à des objets différents d'avoir la même interface, et du coup de pouvoir être utilisé l'un à la place d'un autre. Les messages envoyés aux objets ne changent pas, seul la nature du destinataire change. Pour le client, il n'a pas à connaitre la nature de son interlocuteur, seulement son nom de variable, et le\r\nmessage qu'il veut leur envoyer.\r\n\r\nL'héritage est aussi propre à l'implémentation du langage de programmation. C++ et Smalltalk sont des langages de Classe, alors que Javascript est un langage de prototype. L'objectif premier de l'héritage est d'éviter la duplication de code en permettant à des sous-classes ou sous-object de réutiliser des fonctionnalités et des variables de la classe mère. Cela permet aussi à des sous-objet de spécialiser certain messages de la classe mère en les surchargeant, c'est à dire en remplaçant\r\nla définition de la méthode d'origine avec leur propre définition. \r\n\r\nComme la méthode hérité agit sur le type de l'object, cela permet d'avoir une structure conditionnelle implicite, sans mot clef, comme 'if'. Par exemple, dans Smalltalk, *True* et *False* sont 2 classes filles de la classe *Boolean*."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:00:41.98-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:15:05.547-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "YGA6u9KgDQCsg7VYDgkDmw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##Design pattern\r\n\r\n### principe de base:\r\n 1. Programmer pour une interface, pas pour une implémentation.\r\n 2. Favoriser la composition des objets par rapport à l'héritage.\r\n\r\n2 objects sont assemblé ensembles (binding) soit à la compilation ou à l'exécution (late binding). La composition d'objets utilise ce mécanisme au maximum, et dans le cas de smalltalk, à l'exécution.\r\n\r\n### Catalogue.\r\n\r\n+--------------+-------------------------+--------------------------------------------------------------------------------------------+----------------------------------------+\r\n| Purpose      | Design pattern          | Aspect that can vary                                                                       | technique used                         |\r\n+--------------+-------------------------+--------------------------------------------------------------------------------------------+----------------------------------------+\r\n| Creationnal  | Abstract Factory        | families of product object                                                                 | composition d'objet + polymorphisme    |\r\n|              | Builder                 | how a composite object get created                                                         | composition + heritage + polymorphisme |\r\n|              | Factory method          | Subclass of object that is instanciated                                                    | héritage + polymorphisme               |\r\n|              | Prototype               | Class of object this is instanciated                                                       | composition d'objet + polymorphisme    |\r\n|              | Singleton               | The sole instance of a class                                                               | encapsulation                          |\r\n+--------------+-------------------------+--------------------------------------------------------------------------------------------+----------------------------------------+\r\n| Structural   | Adapter                 | Interface to an object                                                                     | Interface                              |\r\n|              | Bridge                  | Implementation of an object                                                                | Interface                              |\r\n|              | Composite               | Structure and composition of an object                                                     | composition d'objet + polymorphisme    |\r\n|              | Decorator               | Responsabilities of an object without subclassing                                          | composition d'objet + polymorphisme    |\r\n|              | Façade                  | Interface to a subsystem                                                                   | Interface                              |\r\n|              | Flyweight               | Storage cost of an object                                                                  | composition d'objet + polymorphisme    |\r\n|              | Proxy                   | how an object is accessed, its location                                                    | Interface                              |\r\n+--------------+-------------------------+--------------------------------------------------------------------------------------------+----------------------------------------+\r\n| Behavioral   | Chain of responsability | Object that can fulfill a request                                                          | composition d'objet + polymorphisme    |\r\n|              | Command                 | When and how a request is fulfilled                                                        | composition d'objet + polymorphisme    |\r\n|              | Interpreter             | grammar and interpretation of a langage                                                    | composition d'objet + polymorphisme    |\r\n|              | Iterator                | How an aggregate's elements are accessed, traversed                                        | polymorphisme                          |\r\n|              | Mediator                | How and which objects interact with each other                                             | Interface                              |\r\n|              | Memento                 | What private information is stored outside of object, and when                             | encapsulation                          |\r\n|              | Observer                | Number of object that depend on another object; how the dependent objects stay up to date  | composition d'objet + polymorphisme    |\r\n|              | State                   | States of an object                                                                        | composition d'objet + polymorphisme    |\r\n|              | Strategy                | an algorithm                                                                               | polymorphisme                          |\r\n|              | Template method         | Steps of an algorithm                                                                      | héritage                               |\r\n|              | visitor                 | operations that can be applied to object without changing their classes                    | composition d'objet                    |\r\n+--------------+-------------------------+--------------------------------------------------------------------------------------------+----------------------------------------+\r\n "
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:01:28.675-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:02:02.908-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "YMcCvtKgDQCshusTDgkDmw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "#programmation fonctionnelle\r\npour la programmation fonctionnelle, tout est fonction \r\n\r\n\r\n### Exemple"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-22T20:00:09.371-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-07-23T00:03:42.782-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "WKpPXc+gDQC93YWzDxVTDQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "**1** est une **fonction** qui n'accepte aucun argment, et qui renvoit toujours l'entier 1. \r\n\r\nLa programmation fonctionnelle suit une logique et une rigueur qui se rapproche de la rigueur mathématique. En effet, en principe, les fonctions ne modifie pas d'états globaux - il n'est donc pas possible d'avoir d'effet de bord dans une fonction, et il est possible de tester une fonction de façon \r\nindépendante.\r\n\r\nDe la même façon, la notion de boucle, comme dans la programmation impérative, n'est pas répandue en programmation fonctionnelle, ou la notion de récursion est beaucoup plus répandue et prononcée\r\n\r\n## lien programmation fonctionnelle et objet.\r\non définit une méthode \"constructeur\" qui renvoie une fonction anonyme (lambda) à l'exécution. \r\nPour rappel, une fonction anonyme englobe (closure) les variables externe qui sont utilisé dans son code. Cette fonction renvoie une procédure (la fonction lambda interne), qui est prête à répondre à certains messages. \r\n\r\nIl n'y a pas de classes, mais si nous définissons 2 objets avec des noms différents, la methode *name* renverra 2 résultats différents. Les 2 méthodes auront le même comportement, mais retourneront différents états.\r\n\r\n```\r\n(define (make-named-object name)\r\n    (lambda (message)\r\n        (cond ((eq? message 'name) (lambda (self) name))\r\n            (else (no-method name))\r\n        )\r\n    )\r\n)\r\n```\r\n[source](http://www.michaelharrison.ws/weblog/2008/07/sicp-revisited-oop-in-scheme/)\r\n\r\nSi on assigne la fonction lambda à une variable, on retrouve bien un appel du type `(MyObjectInstance myMethod)`"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2022-07-22T19:59:41.368-04:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2022-07-22T20:00:07.975-04:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "paradigme de programmation"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "c0f24e5d-cfa0-0d00-bddc-c5130f15530d"
	}
}