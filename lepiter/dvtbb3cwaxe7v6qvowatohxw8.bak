{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:44:54.717-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T11:01:57.322-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "4A7s2xiHDQCBteAGDkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##introduction\r\n\r\nYour language isn't broken, it's doing floating point math. **Computers can only natively store integers**, so they need some way of representing decimal numbers. This representation comes with some degree of inaccuracy. That's why, more often than not, .1 + .2 != .3.\r\n\r\nThe most common situation is illustrated by the decimal number 0.1. Although it has a finite decimal representation, in binary it has an **infinite** repeating representation.\r\n \r\nWhy does this happen? It's actually pretty simple. When you have a base 10 system (like ours), it can only express fractions that use a prime factor of the base. The prime factors of 10 are 2 and 5. So 1/2, 1/4, 1/5, 1/8, and 1/10 can all be expressed cleanly because the denominators all use prime factors of 10. \r\n\r\nIn contrast, 1/3, 1/6, and 1/7 are all repeating decimals because their denominators use a prime factor of 3 or 7. In binary (or base 2), the only prime factor is 2. So you can only express fractions cleanly which only contain 2 as a prime factor. \r\n\r\nIn binary, 1/2, 1/4, 1/8 would all be expressed cleanly as decimals. While, 1/5 or 1/10 would be repeating decimals. So 0.1 and 0.2 (1/10 and 1/5) while clean decimals in a base 10 system, are repeating decimals in the base 2 system the computer is operating in. When you do math on these repeating decimals, you end up with leftovers which carry over when you convert the computer's base 2 (binary) number into a more human readable base 10 number.\r\n\r\nIf the leading digit is nonzero, then the representation is said to be normalized. Requiring that a floating-point representation be normalized makes the representation unique. Since floating-point numbers are always normalized, the most significant bit of the significand is always 1, and there is no reason to waste a bit of storage representing it. Formats that use this trick are said to have a hidden bit.\r\n\r\n**IEEE 754 single precision**, described here, is encoded in 32 bits using \r\n- 1 bit for the sign, \r\n- 8 bits for the exponent, and \r\n- 23 bits for the significand (mantissa). \r\n\r\nHowever, it uses a hidden bit, so the significand is 24 bits (p = 24), even though it is encoded using only 23 bits. It can be read with formula like\r\n`(-1)^sign * 2^(exponent - 127) * (1 + sum(i = 1 -> 23) b(i)*2^-i)`"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:45:17.763-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:55:04.591-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "KNC72hiHDQCBtC0wDkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##Exemple: get 0.1 as float in 4 easy steps.\r\n\r\n```txt\r\ns eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm    1/n\r\n0 01111011 10011001100110011001101\t=> 1/10, chiffre en 32 bits.\r\n```\r\n### Step 1. s: signe du chiffre (positif ou négatif)\r\nSur 1 bit\r\n`0: positif`\r\n`1: négatif`\r\n\r\n**=> 0, we deal with a positive number**"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:48:57.291-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:55:35.45-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "KEHt5xiHDQCByG7iDkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 2. eeeeeee: Exposant or multiplier (la puissance à laquelle est poussé le chiffre)\r\nou biased exponent - trouvé par la formule `2^(k-1) - 1 => 2^(8 -1) - 1 = 127`\r\nLa valeur de l'exposant est ` '2^(exponent - 127)'`\r\nsur 8 bits 0 -> 255\r\n`  00000000\t=> 0`\r\n`+ 01000000\t=> 64`\r\n`+ 00100000    => 32`\r\n`+ 00010000\t=> 16`\r\n`+ 00001000    => 8`\r\n`+ 00000010    => 2`\r\n`+ 00000001\t=> 1`\r`= 01111011    => 123`"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:55:14.589-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:55:41.146-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "YNGDOsH6DQCMOEfuDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 3: Unbias the Exponent\r\nThe result from the previous step is biased, with a bias of 127. As such, you'll need to subtract 127 from this value. \r\n\r\nexponant =  2^(exponent - 127) = `2^(123 - 127) = 2^(-4)`\r\n**=> exponant = 2^-4 ou 1/16.**"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:48:42.922-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:56:03.687-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "yFby5hiHDQCBxpAEDkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 4. mmmmmmmmmmmmmmmmmmmmmmm: mantissa or fraction\r\nsur 23 bits: 1/2 -> 1/8388608\r\nIt consists of 1 (the implicit base) plus (for all those bits with each being \r\nworth 1/(2^n) as n starts at 1 and increases to the right). Remember that 1 bit\r\nis hidden (see normalized text above)\r\n`  10000000000000000000000 => 1/2 (1/2^1) `\r\n`+ 00010000000000000000000 => 1/16 (1/2^4)`\r\n`+ 00001000000000000000000 => 1/32 (1/2^5)\t`\r\n`+ 00000001000000000000000 => 1/256`\r\n`+ 00000000100000000000000 => 1/512`\r\n`+ 00000000000100000000000 => 1/4096`\r\n`+ 00000000000010000000000 => 1/8192`\r\n`+ 00000000000000010000000 => 1/65536`\r\n`+ 00000000000000001000000 => 1/131072 `\r\n`+ 00000000000000000001000 => 1/1048576`\r\n`+ 00000000000000000000100 => 1/2097152 `\r\n`+ 00000000000000000000001 => 1/8388608 (1/2^23) `\r\n`= 10011001100110011001101 => 1.60000002384185791015625`\r\n\r\n**mantissa = 1.60000002384185791015625**"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:48:10.606-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:57:01.889-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "sF0+IcH6DQCKNzoHDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 5. Calculate the Magnitude of the Overall Value - mantisse * exposant\r\nUsing the mantissa calculation from the previous step, as well as the unbiased exponent from step 3, the overall magnitude of the number will be: `(1 + mantissa) * 2^(unbiased_exponent)`\r\n \r\n `= 1.60000002384185791015625 * 1/16 = 0.100000001490116119384765625`\r\n \r\n** We are a little offset from our matical representation of 0.1**"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:57:35.95-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:57:53.79-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "yNDwQsH6DQCNTxb5DFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### step 6 -  Factor in the Sign Bit\r\nIf the number is positive (determined from step 1), then the magnitude from the previous step is the final result. If the number is negative (from step 1), then negate the magnitude from the previous step. This negated magnitude is the final result."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:55:17.685-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:55:23.081-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "iLiL/hiHDQCBzEA3DkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##The 0.5 example is substantially easier. It's represented as:\r\n`s eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm`\r\n`0 01111110 00000000000000000000000`\r\n\r\nwhich means it's the implicit base, 1, plus no other additives (all the mantissa bits are zero).\r\n\r\nThe sign is again positive. \r\nThe exponent is 64+32+16+8+4+2 = 126 - 127 bias = -1.\r\nHence the multiplier is 2-1 which is 1/2 or 0.5.\r\n\r\nSo the final value is 1 multiplied by 0.5, or 0.5. Voila!\r"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:56:29.89-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:56:53.222-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "iFeYAhmHDQCBzRl9DkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "#An example of rounding issue with floating point representation"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T15:00:11.076-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T11:00:09.896-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "0NcDEBmHDQCCamFCDkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "This is known as ”Muller’s Recurrence,” crafted to highlight how quickly and dramatically floating point roundoff errors can cause things to fall apart, given the right (well, wrong) conditions.\r\n\r\nthese notes discuss only interconversions, **not operations on floating point numbers** (e.g., addition, multiplication, etc.). These operations on floating point numbers are much more complex than their equivalent operations on decimal numbers, mostly due to the need for rounding and precision loss concerns. As such, we do not cover these operations"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:38:00.486-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:56:18.676-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "cDzHwBiHDQCBlaPxDkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "{{gtClass:Muller|expanded=false}}"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:51:50.889-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:51:55.587-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "cJJfLsH6DQCKhJnyDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "## Converting Between Decimal and Binary Floating-Point Numbers"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:52:09.77-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T11:04:27.896-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "KLR/L8H6DQCKnF8nDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 1: Determine Sign\r\nIf the number is positive, then the sign bit will be 0. If the number is negative, then the sign bit will be 1. For the number zero, both positive and negative zero are possible, and these are considered different values (a quirk of using sign bits).\r\n\r\nfor 0.1, the sign is positive, so first digit is 0."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:52:18.104-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T11:05:09.319-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "2N7+L8H6DQCKun5wDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "###Step 2: Convert the Integral Portion to Unsigned Binary\r\nConvert the integral portion of the floating-point value to unsigned binary (not two's complement). The integral portion is the part of the number before the decimal point. \r\n\r\nFor example, if the number to convert is -0.75, then 0 is the integral portion, and it's unsigned binary representation is simply 0. As another example, if the number to convert is 127.99, then the integral portion would be 127, and it's unsigned binary representation is 1111111.\r\n\r\nFor 0.1, the unsigned binary representation is 0."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:52:44.747-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T11:11:46.809-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "EGmVMcH6DQCK4TfXDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 3: Convert the Fractional Portion to Binary\r\nThe fractional portion of the number must also be converted to binary, though the conversion process is much different from what you're used to. The algorithm you'll used is based on performing repeated multiplications by 2, and then checking if the result is >= 1.0. \r\n\r\nIf the result is >= 1.0, then a 1 is recorded for the binary fractional component, and the leading 1 is chopped of the result. \r\n\r\nIf the result is < 1.0, then a 0 is recorded for the binary fractional component, and the result is kept as-is. The recorded builds are built-up left-to-right. The result keeps getting chained along in this way until one of the following is true: *The result is exactly 1.0*\r\n\r\n23 iterations of this process have occurred; i.e. the final converted binary value holds 23 bits\r\nWith the first possible terminating condition (the result is exactly 1.0), this means that the fractional component has been represented without any loss of precision. With the second possible terminating condition (23 iterations have passed), this means that we ran out of bits in the final result, which can never exceed 23. In this case, precision loss occurs (an unfortunate consequence of using a finite number of bits).\r\n\r\nfor 0.1\r\n\r\n```txt\r\n- 0.1 * 2 = 0.2 < 1 => 0\r\n- 0.2 * 2 = 0.4 < 1 => 00\r\n- 0.4 * 2 = 0.8 < 1 => 000\r\n- 0.8 * 2 = 1.6 > 1 => 0001\r\n- 0.6 * 2 = 1.2 > 1 => 00011 \r\n- 0.2 * 2 = 0.4 < 1 => 000110\r\n... to a total of 23 iteration to get 0011001100110011001101\r\n```"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:53:23.212-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T11:12:45.433-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "+FbgM8H6DQCLCRx3DFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 4: Normalize the Value via Adjusting the Exponent\r\nA trick to encode an extra bit is to make it so that the binary scientific representation is always of the form *1.XXXX * 2YYYY*. That is, a 1 always leads, so there is no need to explicitly encode it. In order to encode this properly, we need to move the decimal point to a position where it is immediately after the first 1, and then record exactly how we moved it. \r\n\r\nTo see this in action, consider again the example of 0.75, which is encoded in binary as such (not IEEE-754 notation): 0.11 In order to make the decimal point be after the first 1, we will need to move it one position to the right, like so: 1.1\r\n\r\nMost importantly, we need to record that we moved the decimal point by one position to the right. Moves to the right result in negative exponents, and moves to the left result in positive exponents. In this case, because we moved the decimal point one position to the right, the recorded exponent should be -1."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:53:41.515-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:58:21.67-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "EJ/3NMH6DQCLRQaDDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "###Step 5: Add Bias to the Exponent\r\nInternally, IEEE-754 values store their exponents in an unsigned representation, which may seem odd considering that the exponent can be negative. Negative exponents are accomodated by using a biased representation, wherein a pre-set number is always subtracted from the given unsigned number. Because the given unsigned number may be less than this number, this allows for negative values to be effectively encoded without resorting to two's complement. Specifically, for the binary32 representation, the number 127 will be subtracted from anything encoded in the exponent field of the IEEE-754 number. As such, in this step, we need to add 127 to the normalized exponent value from the previous step.\r\n\r\nTo see this in action, if we recorded an exponent of -1 in the previous step, then the result of this step should be 126 (-1 + 127 = 126). Similarly, if we recorded an exponent of 6 in the previous step, the the result of this step should be 133 (6 + 127 = 133)."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:53:55.107-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:58:15.752-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "0ATHNcH6DQCLY/4UDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "###Step 6: Convert the Biased Exponent to Unsigned Binary\r\nThe biased exponent value from the previous step must be converted into unsigned binary, using the usual process. The result must be exactly 8 bits. It should not be possible to need more than 8 bits. If fewer than 8 bits are needed in this conversion process, then leading zeros must be added to the front of the result to produce an 8-bit value."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:54:09.937-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:54:14.369-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "gE6pNsH6DQCLgOcwDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 7: Determine the Final Bits for the Mantissa\r\nAfter step 4, there are a bunch of bits after the normalized decimal point. These bits will become the mantissa (note that we ignore the bits to the left of the decimal point - normalization allows us to do this, because it should always be just a 1). We need exactly 23 mantissa bits. If less than 23 mantissa bits follow the decimal point, and the algorithm in step 3 ended with a result that wasn't 1.0, then follow the algorithm in step 3 until we can fill enough bits. If that's still not enough (eventually reaching 1.0 before we had enough bits, or perhaps it had ended with 1.0 already), then the right side can be padded with zeros until 23 bits is reached.\r\n\r\nIf there are more than 23 bits after the decimal point in step 4, then these extra bits are simply cutoff from the right. For example, if we had 26 bits to the right of the decimal point, then the last three would need to be cutoff to get us to 23 bits. Note that in this case we will necessarily lose some precision."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:54:36.165-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:54:40.268-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "iIc5OMH6DQCLnmavDFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "### Step 8: Put it All Together\r\nThe sign bit from step 1 will be the first bit of the final result. The next 8 bits will be from the exponent from step 6. The last 23 bits will be from the mantissa from step 7. The result will be a 32-bit number encoded in IEEE-754 binary32 format, assuming no mistakes were made in the process."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:58:33.798-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T10:59:15.092-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "iIFjRsH6DQCNrlp+DFV7dQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##and Beyond!\r\nThe above rules cover the usual sort of numbers we wish to represent. However, there are still some cases which are not accounted for above. We won't get into these cases in this class, though a birds-eye view of them is presented below for the curious.\r\n\r\n* **Zero:** encoded with exponent and mantissa fields consisting of nothing but zeros. Both positive zero and negative zero exists, thanks to the sign bit.\r\n\r\n* **Infinity:** A finite representation of both positive and negative infinity exists. Infinity is encoded with an exponent of all ones and a mantissa of all zeros. The sign bit encodes whether the infinity is positive or negative.\r\n\r\n* **NaN:** Not-a-number. This is a special value that indicates either an indeterminate value, or is the result of a nonsensical operation. These are encoded with an exponent of all ones and a mantissa of all zeros.\r\n\r\n* **Subnormal numbers:** These are specifically for representing values close to zero, and make it so the IEEE-754 standard has higher precision specifically between 0 and 1 than between other numbers. These are useful because this range tends to be especially important for a wide variety of applications, including statistics. These are encoded by an exponent of all zeros and a non-zero mantissa."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2021-08-29T14:36:30.288-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-09-09T11:01:28.942-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "eJ7LsRiHDQCBkgy/DkyD6g=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "#References:\r\nhttps://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html.\r\nhttps://stackoverflow.com/questions/3448777/how-to-represent-0-1-in-floating-point-arithmetic-and-decimal\r\nhttps://www.h-schmidt.net/FloatConverter/IEEE754.html\r\nhttps://en.wikipedia.org/wiki/IEEE_754-1985\r\nhttps://en.wikipedia.org/wiki/Guard_digit\r\nhttp://0.30000000000000004.com/\r\nhttps://kyledewey.github.io/comp122-fall17/lecture/week_2/floating_point_interconversions.html\r\nhttps://en.wikipedia.org/wiki/Floating-point_arithmetic"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2021-08-29T14:33:49.079-04:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2021-08-29T14:36:56.616-04:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "How float number are managed in current computer"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "d811cbb1-1887-0d00-8191-726f0e4c83ea"
	}
}