Notes sur TDD - tiré du livre TDD de Kent Beck

"Conservative montain climbers have a rule that of your four hands and feet, 
three of them must be attached at any one time. Dynamic move where you let go
of two at once are much more dangerous. The pure form of TDD, where you are never
more than one change away from a green bar, is like that three out of four rule

If I can think of a test that might not work, getting it to work is more 
important than releasing my code"
-------------------------------------------------------------------------------
2 Steps:
- Write a failing automated test before you write any code.
- Remove duplication.

The full cycle is:
1. Add a little test.
2. Run all tests and fail.
3. Make a little change.
4. Run the tests and succeed.
5. Refactor to remove duplication.

The general TDD cycle is:
1. Write a test. Think about how you would like the operation in your mind to 
appear in your code. You are writing a story. Invent the interface you wish you 
had. Include all the elements in the story that you imagine will be necessary to
calculate the right answers.

2. Make it run. Quickly getting that bar green dominates everything else. If a 
clean, simple solution is obvious, type it in. If the clean, simple solution is
obvious but it will take you a minute, make a note of it and get back to the 
main problem, which is getting the bar green in seconds. This shift in aesthetics
is hard for some experienced software engineers. They only know how to follow
the rules of good engineering. Quick green excuses all sins. But only for a moment.

3. Make it right. Now that the system is behaving, put the sinful ways of the 
recent past behind you. Step back onto the straight and narrow path of software
righteousness. Remove the duplication that you have introduced to get to quick green.
-------------------------------------------------------------------------------
Principles:
- We don't start with object, we start with tests.
- Start small or not at all.
- When we write a test, we imagine the perfect interface for our operation. We 
are telling ourselves a story about how the operation will look from the outside.

Gradually generalized the working code, replacing constants with variables.
Add items to your todo list, rather than addressing them all at once.

-------------------------------------------------------------------------------
Question to ask:
* Where should you start building a system ? With stories you want to be able to 
tell about the finished system.
* Where should you start writing a bit of functionnality ? With the test you want
to pass with the finished code.
* Where should you start writing a test ? With the assert that will pass when it 
is done.

There is a flip side ot taking breaks. Sometimes, when faced with a tough problem
what you need to do is press on, push through it. However, programming culture is
so infected with macho, "I'll ruin my health, alienate my family, and kill myself
if necessary" spirit that I don't feel compelled to give any advice along these lines.
If you find yourself caffeine-addicted and making no progress whatsoever, perhaps
you shouldn't take quite so many breaks. In the meantime, take a walk.

Get Cheap/slow/old machines for individual email and surfing, and the hottest 
possible machines for shared development.
-------------------------------------------------------------------------------

Starter test:
Which test should you start with ? Start by testing a variant of an operation that
doesn't do anything. The first question you have to ask with a new operation is
"where does it belong ?" Until you've finished this question, you don't know
what to type for the test.

Learning test:
As alternative is to notice that we are about to use a new method of a new class.
Instead of just using it, we write a little test that verifies that the API works
as expected.

Regression test:
What's the first thing you do when a defect is reported ? Write the smallest possible
test that fails, and that once it runs, the defect will be repaired.

Mock Object:
How do you test an object that relies on an expensive or complicated resource ?
Create a fake version of the resource that answers constants.

Broken test:
How do you leave a programming session when you're programming alone ? Leave the
last test broken. 

Fake it:
What is your first implementation once you have a broken test ? Return a constant.
Once you have the test running, gradually transform the constant into an 
expression using variables.

One to Many:
How do you implement an operation that works with collections of objects ? 
Implement it without the collection first, then make it work with collections.

Assertions:
If you are going to make the tests fully automated, every bit of human judgement
has to be taken out of the evaluation of the results. We need to push a button
and have all the decisions necessary to verify the correct working of the code
run by the computer.

Fixture:
How do you create common objects needed by several tests ? Convert the local 
variables in the tests into instance variables. Override setUp and initialize
those variables.



