Note thread/active object pharo smalltalk
------------------------------------------

On recherche la programmation parallèle pour 2 raisons principales:
1. La réactivité d'une application et l'isolation d'un processus
	Ex: Interface Graphique, appel de base de donnée.
	
2. La puissance de calcul (scalability)
	Ex: calcul distribué sur plusieurs coeurs/instance.
	
Ces 2 problèmes peuvent entrainer des soucis de cohérence des donnée (consistency)
	Ex: donnée partagée entre plusieurs thread (espace mémoire commun)

Programmation parallèle ou Concurrente -> pas important, ce qu'il faut, c'est de
synchroniser les évèmenents entre thread:
- Sérialization: Evt A doit se faire avant Evt B
- Mutual exclusion: Evt A et B ne peuvent arriver en même temps.

Le problème se pose surtout avec les variables partagés entre plusieurs contexte
d'exécution, en particulier sur lors d'écriture concurrente (initialisation ou
mise à jour).

La programmation multi-thread peut être utile, ne serait-ce que pour 
garder une interface utilisateur réactive en cas de calcul intensif.


Base sur les thread:
------------------------------------------
Création d'un nouveau thread:
[ command ] fork.
ou
[ command] newProcess resume

Synchronisation avec les sémaphores - permet de bloquer l'accès à une variable.
sem := Semaphore new
sem wait <-> sem signal 

il faut que le nombre de wait et de signal correspondent pour libérer le sémaphore.

Ex: forkAndWait
	"Suspend current process and execute self in new process, when it completes resume current process"

	| semaphore |
	semaphore := Semaphore new.
	[self ensure: [semaphore signal]] fork.
	semaphore wait.

	
Problème avec les threads et sémaphores:
------------------------------------------
- deadlock => 2 thread s'attende mutuellement avant de continuer leur travail.

- race condition => le contenu d'une variable peut être lu et mis à jour par plusieurs
thread concurrent.

les problèmes décrits sont par exemple:
- producer-consumer
- readers-writers
- no-starve
- dining philosophers
- cigarette smokers.

=> code bas niveau, nécessitant de suivre tout les accès concurrent à une variable.
Un livre entier a été écris pour les problèmes: "Little Book of Semaphores".
Il faut identifier les patterns de synchronisation rencontrés, avant de mettre 
en place la solution appropriées.


Le pattern Active Object - Future - promises.
---------------------------------------------
Future, promise, delay, and deferred refer to constructs used for synchronizing 
program execution in some concurrent programming languages. a future is a 
read-only container for a result that does not yet exist, while a promise can 
be written (normally only once). 

Comme le dit Herb Sutter: "Use Threads Correctly = Isolation + Asynchronous Messages "
and "Effective Concurrency: Prefer Using Active Objects Instead of Naked Threads"

With an active object, method invocation is decoupled from the actual method 
execution, i.e. invoked methods of these objects are executed asynchronously 
and do not block the caller. 

The concurrency functionality is achieved by running methods in a thread 
or process context different from that of the caller. Possible results of active 
methods are encapsulated in so called future objects which can be seen as 
placeholders or contracts for the real results. A future is basically a join 
point or rendez-vous for the caller and the active object. 
 
The basic idea is to take a block of code, schedule it on another thread and 
return a dynamic proxy that if accessed, blocks until the value returns.

a subclass of ProtoObject since we're building a proxy
	ProtoObject subclass: #SFuture
		instanceVariableNames: 'futureValue error lock'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'OnSmalltalk'
	
Then a #value: write accessor which eagerly kicks off the process, sets up, and 
clears the lock after fetching the future value.
	value: aBlock 
    lock := Semaphore new.

    [ [ futureValue := aBlock value ] 
        on: Error
        do: [ :err | error := err ]
        ensure: [ lock signal ] ] forkBackground

Now a #value read accessor that blocks if the lock still exists, re-throws any 
error that may have happened on the worker thread in the context of the main 
thread, and finally returns the future value.
	value
    lock isSignaled ifFalse: [ lock wait ].
    error ifNotNil: 
        [ error
            privHandlerContext: thisContext;
            signal ].
    ^ futureValue
	
A quick testing method for checking if the future has finished executing 
(useful for doing what work you can with the results that have returned).

	hasValue
		^ lock isSignaled

And the all important #doesNotUnderstand: override that intercepts any message 
sent to the proxy and sends it to the future value, causing the thread to block 
until the result is finished computing.

	doesNotUnderstand: aMessage 
		^ self value 
			perform: aMessage selector
			withArguments: aMessage arguments
		
Finally, a single extension method to BlockContext to make using the future more 
natural and ensuring to call fixTemps so I can collect future values in a loop 
with the assumption that the block will act like a proper closure.

	BlockClosure>>future
		^ SFuture new value: self fixTemps
		
Usage:
	value1 := [200 timesRepeat:[Transcript show: '.']. 6] future.
	value2 := [200 timesRepeat:[Transcript show: '+']. 6] future.
	Transcript show: 'other work'.
	Transcript show: (value1 + value2).

La solution Pharo Smalltalk - utiliser TaskIt
---------------------------------------------
https://github.com/sbragagnolo/taskit



Reference:
---------------------------------------------
http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html
http://onsmalltalk.com/smalltalk-concurrency-playing-with-futures
https://en.wikipedia.org/wiki/Futures_and_promises
https://blog.gurock.com/wp-content/uploads/2008/01/activeobjects.pdf
https://medium.com/swlh/what-you-need-to-know-about-asynchronous-programming-in-javascript-894f90a97941
https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Utiliser_les_promesses
